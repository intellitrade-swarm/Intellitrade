#!/usr/bin/env python3
"""
Nexus Trend-Following Agent v1.1 (Cleaned & Production-Ready)
============================================================

Medium-term trend follower using EMA alignment + ADX strength.
Uses Asterdex perpetual futures (Binance-compatible API).

Key fixes & improvements:
- Confirmed X-MBX-APIKEY header
- reduceOnly on position closes
- Proper error checking on orders
- Safer trailing stop (price-based)
- requests library for HTTP
- Removed dead SwarmsAI code
- Better logging & state management

Author: IntelliTrade AI Team
Version: 1.1
"""

import os
import json
import time
import hmac
import hashlib
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, field
from enum import Enum

import requests  # pip install requests

# ────────────────────────────────────────────────
# Logging
# ────────────────────────────────────────────────
logging.basicConfig(
    level=logging.INFO,
    format="[%(asctime)s] NEXUS │ %(levelname)-7s │ %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)
logger = logging.getLogger(__name__)


# ────────────────────────────────────────────────
# Enums
# ────────────────────────────────────────────────
class TrendDirection(Enum):
    STRONG_UP = "STRONG_UPTREND"
    UP = "UPTREND"
    SIDEWAYS = "SIDEWAYS"
    DOWN = "DOWNTREND"
    STRONG_DOWN = "STRONG_DOWNTREND"


class TradeSide(Enum):
    LONG = "LONG"
    SHORT = "SHORT"


class TimeFrame(Enum):
    M5 = "5m"
    M15 = "15m"
    H1 = "1h"


# ────────────────────────────────────────────────
# Data Classes
# ────────────────────────────────────────────────
@dataclass
class TrendAnalysis:
    symbol: str
    direction: TrendDirection
    adx: float              # trend strength
    ema_aligned: bool
    momentum_pct: float
    atr_pct: float
    support: float
    resistance: float
    timeframe: TimeFrame = TimeFrame.M15
    timestamp: datetime = field(default_factory=datetime.now)

    @property
    def is_tradeable(self) -> bool:
        return self.direction not in (TrendDirection.SIDEWAYS,) and self.adx >= 25


@dataclass
class TradeSignal:
    symbol: str
    side: TradeSide
    confidence: float
    entry_price: float
    stop_loss: float
    take_profit: float
    analysis: TrendAnalysis


@dataclass
class Config:
    symbols: List[str] = field(default_factory=lambda: ["BTCUSDT", "ETHUSDT", "SOLUSDT"])
    min_trade_usd: float = 40.0
    max_trade_usd: float = 180.0
    max_positions: int = 5
    leverage: int = 10
    daily_target_usd: float = 80.0
    check_interval_sec: int = 45
    cooldown_sec: int = 90
    min_adx: float = 28.0
    min_confidence: float = 0.80
    ema_periods: Tuple[int, int, int] = (9, 21, 50)
    atr_period: int = 14


# ────────────────────────────────────────────────
# Indicators (pure Python)
# ────────────────────────────────────────────────
class Indicators:
    @staticmethod
    def ema(prices: List[float], period: int) -> List[float]:
        if len(prices) < period:
            return prices[:]
        multiplier = 2 / (period + 1)
        ema = [sum(prices[:period]) / period] * period
        for p in prices[period:]:
            ema.append((p - ema[-1]) * multiplier + ema[-1])
        return ema

    @staticmethod
    def atr(highs: List[float], lows: List[float], closes: List[float], period: int = 14) -> float:
        if len(closes) < 2:
            return 0.0
        trs = [
            max(h - l, abs(h - closes[i - 1]), abs(l - closes[i - 1]))
            for i, (h, l) in enumerate(zip(highs[1:], lows[1:]), 1)
        ]
        if len(trs) < period:
            return sum(trs) / len(trs) if trs else 0.0
        return sum(trs[-period:]) / period

    @staticmethod
    def adx(highs: List[float], lows: List[float], closes: List[float], period: int = 14) -> float:
        if len(closes) < period + 1:
            return 20.0
        trs, plus_dm, minus_dm = [], [], []
        for i in range(1, len(closes)):
            h_diff = highs[i] - highs[i - 1]
            l_diff = lows[i - 1] - lows[i]
            tr = max(highs[i] - lows[i], abs(highs[i] - closes[i - 1]), abs(lows[i] - closes[i - 1]))
            trs.append(tr)
            plus_dm.append(h_diff if h_diff > l_diff and h_diff > 0 else 0)
            minus_dm.append(l_diff if l_diff > h_diff and l_diff > 0 else 0)

        atr = sum(trs[-period:]) / period if len(trs) >= period else 1.0
        p_dm = sum(plus_dm[-period:]) / period
        m_dm = sum(minus_dm[-period:]) / period
        di_p = 100 * p_dm / atr if atr > 0 else 0
        di_m = 100 * m_dm / atr if atr > 0 else 0
        dx = 100 * abs(di_p - di_m) / (di_p + di_m) if (di_p + di_m) > 0 else 0
        return dx  # simplified (no full Wilder smoothing)

    @staticmethod
    def swing_levels(highs: List[float], lows: List[float], lookback: int = 7) -> Tuple[float, float]:
        if len(highs) < 3:
            return 0.0, 0.0
        return max(highs[-lookback:]), min(lows[-lookback:])


# ────────────────────────────────────────────────
# Main Agent
# ────────────────────────────────────────────────
class NexusAgent:
    BASE_URL = "https://fapi.asterdex.com"

    def __init__(self, config: Optional[Config] = None):
        self.config = config or Config()
        self.ind = Indicators()

        self.api_key = os.getenv("ASTERDEX_API_KEY")
        self.api_secret = os.getenv("ASTERDEX_API_SECRET")
        if not self.api_key or not self.api_secret:
            raise ValueError("Missing ASTERDEX_API_KEY / ASTERDEX_API_SECRET env vars")

        self.session = requests.Session()
        self.session.headers.update({"X-MBX-APIKEY": self.api_key})

        self.positions: Dict[str, Dict] = {}
        self.daily_pnl = 0.0
        self.wins = self.losses = self.total_trades = 0
        self.last_trade_ts = 0.0
        self.trailing_prices: Dict[str, float] = {}   # current trailing stop price
        self.entry_analysis: Dict[str, TrendAnalysis] = {}
        self.klines_cache: Dict[str, List] = {}
        self.cache_ts: Dict[str, float] = {}

        logger.info("Nexus Trend Agent v1.1 initialized")
        logger.info(f"Symbols     : {', '.join(self.config.symbols)}")
        logger.info(f"Position lim: {self.config.max_positions} | Leverage: {self.config.leverage}x")

    def _sign(self, params: Dict) -> str:
        query = "&".join(f"{k}={v}" for k, v in sorted(params.items()))
        return hmac.new(
            self.api_secret.encode(), query.encode(), hashlib.sha256
        ).hexdigest()

    def _request(self, method: str, path: str, params: Optional[Dict] = None) -> dict:
        params = params or {}
        params["timestamp"] = int(time.time() * 1000)
        params["recvWindow"] = 8000

        query = "&".join(f"{k}={urllib.parse.quote(str(v))}" for k, v in sorted(params.items()))
        sig = self._sign(params)
        url = f"{self.BASE_URL}{path}?{query}&signature={sig}"

        try:
            if method.upper() == "GET":
                r = self.session.get(url, timeout=10)
            elif method.upper() == "POST":
                r = self.session.post(url, timeout=10)
            else:
                raise ValueError(f"Unsupported method: {method}")

            r.raise_for_status()
            data = r.json()

            if isinstance(data, dict) and "code" in data and data["code"] != 200:
                raise ValueError(f"API error {data.get('code')}: {data.get('msg')}")

            return data
        except Exception as e:
            logger.error(f"{method} {path} failed ─ {e}")
            raise

    def get_usdt_balance(self) -> float:
        try:
            res = self._request("GET", "/fapi/v2/balance")
            for a in res:
                if a.get("asset") == "USDT":
                    return float(a.get("availableBalance", 0))
            return 0.0
        except:
            return 0.0

    def get_open_positions(self) -> List[Dict]:
        try:
            res = self._request("GET", "/fapi/v2/positionRisk")
            return [p for p in res if float(p.get("positionAmt", 0)) != 0]
        except:
            return []

    def get_klines(self, symbol: str, interval: str = "15m", limit: int = 120) -> List[List]:
        key = f"{symbol}_{interval}_{limit}"
        if key in self.klines_cache and time.time() - self.cache_ts.get(key, 0) < 35:
            return self.klines_cache[key]

        try:
            data = self._request("GET", "/fapi/v1/klines", {"symbol": symbol, "interval": interval, "limit": str(limit)})
            self.klines_cache[key] = data
            self.cache_ts[key] = time.time()
            return data
        except:
            return []

    def analyze(self, symbol: str) -> TrendAnalysis:
        klines = self.get_klines(symbol, "15m", 120)
        if len(klines) < 60:
            return TrendAnalysis(symbol, TrendDirection.SIDEWAYS, 0, False, 0, 0, 0, 0)

        o, h, l, c = [float(k[i]) for i in (1,2,3,4) for k in klines], [], [], []
        opens, highs, lows, closes = [float(k[1]) for k in klines], [float(k[2]) for k in klines], [float(k[3]) for k in klines], [float(k[4]) for k in klines]

        price = closes[-1]

        e9 = self.ind.ema(closes, self.config.ema_periods[0])[-1]
        e21 = self.ind.ema(closes, self.config.ema_periods[1])[-1]
        e50 = self.ind.ema(closes, self.config.ema_periods[2])[-1]

        aligned_up = e9 > e21 > e50
        aligned_dn = e9 < e21 < e50
        aligned = aligned_up or aligned_dn

        adx = self.ind.adx(highs, lows, closes, 14)
        atr = self.ind.atr(highs, lows, closes, self.config.atr_period)
        atr_pct = (atr / price) * 100 if price > 0 else 0

        mom = ((closes[-1] - closes[-20]) / closes[-20]) * 100 if len(closes) >= 20 else 0

        res, sup = self.ind.swing_levels(highs, lows)

        dir_ = TrendDirection.SIDEWAYS
        if aligned_up and adx >= 25:
            dir_ = TrendDirection.STRONG_UP if adx >= 40 else TrendDirection.UP
        elif aligned_dn and adx >= 25:
            dir_ = TrendDirection.STRONG_DOWN if adx >= 40 else TrendDirection.DOWN

        return TrendAnalysis(symbol, dir_, adx, aligned, mom, atr_pct, sup, res)

    def generate_signal(self, ana: TrendAnalysis) -> Optional[TradeSignal]:
        if not ana.is_tradeable or ana.adx < self.config.min_adx:
            return None

        klines = self.get_klines(ana.symbol, "15m", 5)
        if not klines:
            return None
        price = float(klines[-1][4])

        conf = 0.72
        if ana.adx >= 40: conf += 0.12
        elif ana.adx >= 32: conf += 0.07
        if ana.ema_aligned: conf += 0.06
        if abs(ana.momentum_pct) > 2.5: conf += 0.05
        conf = min(0.97, conf)

        if conf < self.config.min_confidence:
            return None

        if ana.direction in (TrendDirection.STRONG_UP, TrendDirection.UP):
            side = TradeSide.LONG
            sl = ana.support * 0.992 if ana.support > 0 else price * 0.97
            tp = price * 1.035   # ~3.5% base – adjust with ATR later
        else:
            side = TradeSide.SHORT
            sl = ana.resistance * 1.008 if ana.resistance > 0 else price * 1.03
            tp = price * 0.965

        return TradeSignal(ana.symbol, side, conf, price, sl, tp, ana)

    def find_best_signal(self, active_pos_symbols: set) -> Optional[TradeSignal]:
        now = time.time()
        if now - self.last_trade_ts < self.config.cooldown_sec:
            return None

        candidates = [s for s in self.config.symbols if s not in active_pos_symbols]
        if not candidates:
            return None

        best, best_score = None, 0.0

        for sym in candidates:
            ana = self.analyze(sym)
            sig = self.generate_signal(ana)
            if not sig:
                continue
            score = ana.adx * sig.confidence
            if score > best_score:
                best, best_score = sig, score

        return best

    def execute(self, sig: TradeSignal, avail_balance: float) -> bool:
        size_usd = min(self.config.max_trade_usd, max(self.config.min_trade_usd, avail_balance * 0.10))
        if size_usd < self.config.min_trade_usd:
            return False

        notional = size_usd * self.config.leverage
        qty = notional / sig.entry_price

        # TODO: fetch from /fapi/v1/exchangeInfo for real precision
        if "BTC" in sig.symbol:
            qty = round(qty, 3)
        elif "ETH" in sig.symbol:
            qty = round(qty, 2)
        else:
            qty = round(qty, 1)

        if qty <= 0:
            return False

        side_str = "BUY" if sig.side is TradeSide.LONG else "SELL"

        try:
            order = self._request("POST", "/fapi/v1/order", {
                "symbol": sig.symbol,
                "side": side_str,
                "type": "MARKET",
                "quantity": str(qty),
                # "positionSide": sig.side.value,  # if hedge mode enabled
            })
            if "orderId" in order:
                self.entry_analysis[sig.symbol] = sig.analysis
                self.trailing_prices[sig.symbol] = sig.stop_loss
                self.last_trade_ts = time.time()
                self.total_trades += 1
                logger.info(f"ENTRY {sig.side.name} {sig.symbol} | qty {qty:.3f} | conf {sig.confidence:.0%}")
                return True
            return False
        except Exception as e:
            logger.error(f"Open failed {sig.symbol}: {e}")
            return False

    def monitor(self):
        pos_list = self.get_open_positions()
        for pos in pos_list:
            sym = pos["symbol"]
            amt = float(pos["positionAmt"])
            if amt == 0:
                continue
            side_str = "LONG" if amt > 0 else "SHORT"
            side = TradeSide.LONG if amt > 0 else TradeSide.SHORT
            pnl = float(pos.get("unRealizedProfit", 0))
            mark = float(pos.get("markPrice", 0))
            entry_p = float(pos.get("entryPrice", 0))

            ana = self.entry_analysis.get(sym)
            adx = ana.adx if ana else 30.0

            # Dynamic-ish target (simplified)
            target_usd = 5.0 + (adx / 20.0) * 4.0   # rough scaling

            # Update trailing stop
            trail = self.trailing_prices.get(sym, 0)
            min_profit_activate = 2.5
            if pnl > min_profit_activate:
                if side is TradeSide.LONG:
                    new_trail = mark * 0.992
                    if new_trail > trail:
                        self.trailing_prices[sym] = new_trail
                else:
                    new_trail = mark * 1.008
                    if trail == 0 or new_trail < trail:
                        self.trailing_prices[sym] = new_trail

            logger.info(f"  {sym:8} {side_str} | PnL ${pnl:+6.2f} | Target ~${target_usd:5.2f}")

            close = False
            reason = ""

            if pnl >= target_usd:
                reason = "TARGET"
                close = True
            elif trail > 0 and pnl > min_profit_activate:
                if (side is TradeSide.LONG and mark < trail) or (side is TradeSide.SHORT and mark > trail):
                    reason = "TRAIL"
                    close = True
            elif pnl >= 4.0:  # quick profit floor
                reason = "QUICK"
                close = True

            if close:
                self._close(pos, reason, pnl)
                continue

            if pnl < 0:
                logger.info(f"  ⏳ Maturing {sym}  down ${abs(pnl):.2f}")

    def _close(self, pos: Dict, reason: str, pnl: float):
        sym = pos["symbol"]
        amt = abs(float(pos["positionAmt"]))
        side_str = "SELL" if float(pos["positionAmt"]) > 0 else "BUY"

        try:
            res = self._request("POST", "/fapi/v1/order", {
                "symbol": sym,
                "side": side_str,
                "type": "MARKET",
                "quantity": str(amt),
                "reduceOnly": "true",
            })
            if "orderId" in res:
                self.daily_pnl += pnl
                if pnl >= 0:
                    self.wins += 1
                    logger.info(f"WIN  {reason} {sym} +${pnl:.2f}")
                else:
                    self.losses += 1
                    logger.info(f"LOSS {reason} {sym} -${abs(pnl):.2f}")
                self.trailing_prices.pop(sym, None)
                self.entry_analysis.pop(sym, None)
        except Exception as e:
            logger.error(f"Close failed {sym}: {e}")

    def run_cycle(self):
        logger.info("─" * 50 + " CYCLE " + "─" * 50)
        bal = self.get_usdt_balance()
        poss = self.get_open_positions()
        active = {p["symbol"] for p in poss}

        logger.info(f"USDT avail: ${bal:,.2f}  |  Positions: {len(poss)} / {self.config.max_positions}")

        if self.daily_pnl >= self.config.daily_target_usd:
            logger.info("Daily target reached → managing only")
        else:
            sig = self.find_best_signal(active)
            if sig:
                self.execute(sig, bal)

        if poss:
            self.monitor()

    def run(self):
        logger.info("NEXUS trend follower started (Ctrl+C to stop)")
        while True:
            try:
                self.run_cycle()
            except KeyboardInterrupt:
                logger.info("Stopped by user")
                break
            except Exception as e:
                logger.exception(f"Cycle error: {e}")
            time.sleep(self.config.check_interval_sec)


def main():
    # Optional: load .env from specific path
    # env_path = "/home/ubuntu/intellitrade/nextjs_space/.env"
    # if os.path.exists(env_path): ...

    agent = NexusAgent()
    agent.run()


if __name__ == "__main__":
    main()
